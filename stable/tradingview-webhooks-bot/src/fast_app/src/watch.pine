//@version=5
strategy("MP - Signal - Alerts Strategy nyc", initial_capital=7500, shorttitle="sig Strat nyc", overlay=true, max_bars_back = 5000, process_orders_on_close =true, default_qty_type= strategy.percent_of_equity, default_qty_value =100)
//@strategy_alert_message {{strategy.order.alert_message}}


sqz_test = input(false, "require sqeeze off")
vol_cond_test = input(false, "volcond = above mean")
five_min_test =  input(false, "no volcond during 1st five min")
// === Strategy Settings ===
// === API Integration Settings ===
unixTime = input.int(1749585293, "Unix Time in seconds",  group="Risk Management")
positionSize = input.float(0, "account Balance", group="Risk Management", tooltip = "This will only be used if greater than 0 thus overriding the strat properties initial_capital")
rewardRiskRatio = input.float(1.0, "Reward/Risk Ratio", minval=0.1,group="Risk Management")
riskPercentage = input.float(1.0, "Risk Percentage", minval=0.1, maxval=10.0,group="Risk Management")
commissionValue = input.float(0.005, "Commission (%)", group="Risk Management")
//maxOpenPositions = input.int(1, "Max Open Positions", minval=1, group="Risk Management")
afterHoursOrder = input.bool(false, "Enable Pre-Market or After Hours Orders", group="Risk Management")

trade_limit = input.int(1, "Trade Limit Number",  group="Risk Management", minval=0)
// group="API Settings"
//useStopLoss_plus_limit =  input.bool(false, "Use Full Bracket Order Strategy", group="Risk Management") 1735914600
pre_rvol_thresh =  input.float(10, "Pre-rVol (%)", group="Risk Management")
limitOrderType =   input.string("Stoploss Only", "Order Type", options=["Stoploss Only", "Bracket Order", "None"], group="API Settings")

stratType = input.string("Trend with Volume Break", "Strategy Type", options=["Trend with Volume Break", "Bull/Bear Break only", "Five Min Scalp", "Test"], group="API Settings")
closeType = input.string("None", "Close Type", options=["Bar Stoploss", "ATR Stoploss", "Profit Target", "None"], group="API Settings")
testEntry = input.bool(false, "Enable Test Entry",group="API Settings")
openprofit_percent_level = input.float(1.5, "Profit Target %")
//submit_cmd = input.bool(true, "Submit Command", group="API Settings")
submit_cmd = true

//   group="Stop Settings" //

atrFactor = input.float(1.5, "ATR Factor", minval=0.1, group="ATR Settings")
stopType = input.string("vStop", "Stop Type", options=["kcStop", "vStop", "pivot"], group="ATR Settings")


vola_level = input.float(4.0, "Volatility Threshold", group="ATR Settings")

vstopLen = input.int(20, "vStop ATR Length",  group="ATR Settings")

//backet_test = input.bool(false, 'Turn on backtesting')


pine_time_tradingday=time_tradingday
timeframe_period=timeframe.period
shortPriceThresh = input.float(4.0, "Short Entry Price Threshold")

//── Inputs

sqz_length   = input.int(20,  "Sqz Length", group="Squeeze Settings")
srSqz= input.source(close, "Sqz Source", group="Squeeze Settings")
bbMult   = input.float(2, "BB 3", group="Squeeze Settings")
kcMult   = input.float(1.5, "KC 3", group="Squeeze Settings") //1136110210



accountBalance =  positionSize > 0 ? positionSize : strategy.initial_capital



var float brokerComish= 0.0
brokerComish         := math.max(math.round((accountBalance / close) * 0.005), 1.0)
var float minCommission  = 1.0
var float maxPercentage  = 0.01

lengthGroupTitle = "LENGTH LEFT / RIGHT"
colorGroupTitle = "Text Color / Label Color"
textColorH = input(title="Pivot High", defval=color.black, inline="Pivot High", group=colorGroupTitle)
labelColorH = input(title="", defval=color.white, inline="Pivot High", group=colorGroupTitle)

textColorL = input(title="Pivot Low", defval=color.black, inline="Pivot Low", group=colorGroupTitle)
labelColorL = input(title="", defval=color.white, inline="Pivot Low", group=colorGroupTitle)
leftBars = input(5, title='Left Bars ')
rightBars = input(5, title='Right Bars')


ocsThresh = input.float(20.0, "Volume Oscillator Threshold", group="Trade Setup")
rsiLn = input.int(8, "RSI Length")

emaLn = input.int(21, "EMA Trend Length")
 
rsiFastLn = input.int(3, "RSI Fast Length")
volLen = input.int(10, title='Volume MA Length', group="Volume Inputs")
period = input.int(5, 'TSI Length', minval = 2)
periodThresLong = input.float(0.5, 'TSI Long Threshold')
periodThresShort = input.float(-0.5, 'TSI Short Threshold')




// === Variables ===
var bool volCond = false
var bool takeProfitBool = false

var bool signalEntryLongScan = false
var bool signalEntryShortScan = false
var bool ismarket = false
var bool tickSubAlert = false
var bool price_update_alert = false
var bool price_update = false
var bool newDay = false
var bool bullBreak = false
var bool bearBreak = false
var bool bullBreakScan = false
var bool bearBreakScan = false
var bool newShortSig = false
var bool newLongSig = false
var bool volCondSig = false
var bool volCondSigScan = false
var int trade_count = 0
var bool newEntry = false
var bool five_min_bar_close_sig = false

var bool shortTrendSig = false
var bool longTrendSig = false
var bool longLevelBreakSig = false
var bool shortLevelBreakSig = false
var float stopLow = na
var float stopHigh = na
var float stopLowAlert = na
var float stopHighAlert = na
var float stopLossLongCalc = na
var float stopLossShortCalc = na
// Positions Calcs
var float QtytS         = na
var float QtytL         = na
var float QtytSAlert         = na
var float QtytLAlert         = na
var float pQtyL         = na
var float pQtyS         = na
var float pQtyLAlert         = na
var float pQtySAlert         = na
var float perShareRisk  = na
var float toleratedRisk = na
var float tradeValue = na
var float commission = na
var float grossCommission = na
var float longTS         = na
var float longEntryPrice      = na
var float longStopPrice  = na
var float longLimitPrice = na

var float shortTS         = na
var float shortEntry      = na
var float shortStopPrice  = na
var float shortLimitPrice = na
var float shortLimitPricePlot = na
var float longTSAlert         = na
var float longEntryAlert       = na
var float longStopPriceAlert   = na
var float longLimitPriceAlert  = na

var float shortTSAlert          = na
var float shortEntryAlert       = na
var float shortStopPriceAlert   = na
var float shortLimitPriceAlert  = na
var bool signalEntryLong = false
var bool signalEntryShort = false 


var float r2 = na
var float s2 = na
var bool longE = false
var bool shortE = false
var bool volumeVar = false
var float atrFactorDyn = na
var bool close_allLong = false
var bool close_allShort = false
var bool closeAllSig = false
var string orderAction = na
var bool alertTriggered     = false
var bool alertTriggeredTS   = false
var bool longCloseTrend     = false
var earnigs_avol_sig = false

var bool shortCloseTrend     = false
var bool noPosition = false
var int totalTrades = na
var int currentTrades = na
var bool commonEntry = false


var float lowestLowPrice = na
var float highestHighPrice = na
var int barsBack = 1
var int barsBackTA = 1



newDay := dayofweek != dayofweek[1]

netprofit_percent=strategy.netprofit_percent 
position_size=strategy.position_size
openprofit_percent = strategy.openprofit_percent
ismarket:=session.ismarket
close_string = close
ticker_info = syminfo.ticker

if newDay
    longStopPrice:=na
    volCond := false
    signalEntryLongScan := false
    signalEntryShortScan := false
    lowestLowPrice :=na
    highestHighPrice :=na
    five_min_bar_close_sig:=false
    newEntry:= false
    trade_count := 0
    grossCommission:= na
    commonEntry := false
    price_update := false
    price_update_alert := false
    signalEntryLong := false
    signalEntryShort := false
    shortLimitPricePlot := na
    currentTrades:= 0
    earnigs_avol_sig := false
    volCondSig := false
    volCondSigScan := false
    bearBreak := false
    bullBreak := false
    bullBreakScan := false
    bearBreakScan := false
    shortTrendSig := false
    longTrendSig := false
    shortLevelBreakSig := false
    longLevelBreakSig := false
    r2 := na
    s2 := na
    volumeVar := false
    stopLow := na
    stopHigh := na
    shortStopPrice  := na
    shortLimitPrice := na
    close_allLong := false
    close_allShort := false
    tickSubAlert := false
    closeAllSig:= false
    longE               := false
    shortE              := false
    noPosition          := position_size == 0
    alertTriggered      := position_size != 0
    alertTriggeredTS    := position_size == 0
    longCloseTrend      := position_size != 0
    shortCloseTrend     := position_size != 0
    totalTrades := 0
if position_size == 0 
    closeAllSig:= false
    longE  := false
    shortE := false
if position_size > 0
    longE := true
if position_size < 0
    shortE := true

currentTrades := dayofweek != dayofweek[1] ? 0 : position_size != position_size[1] ? currentTrades[1] + 1 : currentTrades[1]
unix_opening=pine_time_tradingday+28800000
last_bar_59 = pine_time_tradingday+71940000
time_unix = time
five_min_bar_close = pine_time_tradingday+ 48915000
five_min_bar_close_sig:=time_unix<=five_min_bar_close

plotshape(five_min_bar_close_sig,"five_min_bar_close_sig")
//boofRequest = input.bool(false, "Boof Request")
//unixTimeCond = not backet_test ? time_unix > unixTime : time_unix > 0
unixTimeCond = time_unix > (unixTime*1000)


barsBack := ta.barssince(newDay)
if barsBack < 1 or na(barsBack)
    barsBackTA := 1
if barsBack >=1 and not  na(barsBack)
    barsBackTA := barsBack

//lowestLowPrice := ta.lowest(fixnan(barsBackTA))
//highestHighPrice := ta.highest(fixnan(barsBackTA))
day_of_week = dayofweek
isweekend = day_of_week == 6 or day_of_week == 7
htfX = barstate.isrealtime and (not session.ismarket or  isweekend) ? 0 :  barstate.isrealtime and  session.ismarket and not isweekend ? 1 : 0
nowX = barstate.isrealtime ? 0 : 1



[open1D,  high1D, low1D, close1D] = request.security(syminfo.tickerid, "1D", [open[htfX], high[htfX], low[htfX], close[htfX]], lookahead = barmerge.lookahead_on)


close_spy_d=close1D[nowX]
//lowestLowPrice:=ta.valuewhen(session.ismarket, close, 0)
pine_tr = (math.max(high1D - low1D, math.abs(high1D - close1D[1]), math.abs(low1D - close1D[1]))) * 100 / math.abs(low1D) 
//lowestLowPrice:=ta.valuewhen(ismarket, close, 0)

if pine_tr < 10.0 or na(pine_tr)

    atrFactorDyn := atrFactor
if pine_tr >= 10.0 and pine_tr < 20.0  and not na(pine_tr) 
    atrFactorDyn := 2.0
if pine_tr >= 20.0 and pine_tr < 50.0  and not na(pine_tr) 

    atrFactorDyn := 2.5
if pine_tr >= 50  and not na(pine_tr) 
    atrFactorDyn := 3.0
plotshape(pine_tr, title = 'pine_tr', color=color.white, style=shape.cross, display = display.none)

//===========================Stop Loss Calcs=========================================================================================


ATR=ta.atr(10)

ema = ta.ema(close, 20)

kcUpper = ema + ATR * atrFactor 
kcLower = ema - ATR * atrFactor 

atrVstop =ta.atr(vstopLen)
volStop(hl2, vstopLen, atrfactor) =>
    if not na(hl2)
        var max     = hl2
        var min     = hl2
        var bool uptrend_fn = true
        var float stop    = na
        atrM        = nz(atrVstop * atrfactor, ta.tr)
        max         := math.max(max, hl2)
        min         := math.min(min, hl2)
        stop        := nz(uptrend_fn ? math.max(stop, max - atrM) : math.min(stop, min + atrM), hl2)
        uptrend_fn     := hl2 - stop >= 0.0
        if uptrend_fn != uptrend_fn[1] 
            max    := hl2
            min    := hl2
            stop   := uptrend_fn ? max - atrM : min + atrM
        [stop, uptrend_fn]

[vStop, uptrend] = volStop(hl2, vstopLen, atrFactorDyn)
[vStop_SL, uptrend_SL] = volStop(hl2, 3, 3)
uptrend_change=ta.change(uptrend) 
var bool trendChangeL = false
var bool trendChangeS = false
atrLongSqx = vStop_SL > low and  uptrend
atrShortSqx = vStop_SL < high and not uptrend
trendChangeL:= uptrend ? not uptrend[1] : false

trendChangeS:= not uptrend ?  uptrend[1] : false

// === Pivot Points ===
ph = fixnan(ta.pivothigh(2, 3)[1])
pl = fixnan(ta.pivotlow(2, 3)[1])
ph2 = fixnan(ta.pivothigh(leftBars, rightBars)[1])
pl2 = fixnan(ta.pivotlow(leftBars, rightBars)[1])
r1 = na(ph) ? na : ph
s1 = na(pl) ? na : pl
r2 := na(ph2) ? na : ph2
s2 := na(pl2) ? na : pl2
plot(r2, "r2 pivothigh", color=color.green, display = display.none)
//plot(ph2, "ph2 pivothigh", color=#fbff06, display = display.none)

plot(s2, "s2 pivotlow", color=color.red, display = display.none)

//---------------vwap Condiditon-----------------
// Time Variables
var bool vwapSigShort = false
var bool vwapSigLong =  false
var float highest_volume = na
var bool anchor = false
var bool vwap_reset = false
if not session.ismarket and not timeframe.isdaily
    vwap_reset:=session.ispostmarket and  session.ispostmarket[1] and not session.ispostmarket[2]
    vwapSigLong := false
    vwapSigShort := false
if session.ismarket and not timeframe.isdaily
    vwap_reset:= session.isfirstbar_regular
if vwap_reset and not timeframe.isdaily
    highest_volume := volume
    anchor := true
    
else
    if volume > nz(highest_volume) and not timeframe.isdaily
        highest_volume := volume
        anchor := true
    else
        anchor := false        

// Calculate vwap levels
[vwap, upperVwap, lowerVwap] = ta.vwap(close, anchor, 2)
[vwapLow, upperLow, lowerLow] = ta.vwap(low, anchor, 2)
[vwapHigh, upperHigh, lowerHigh] = ta.vwap(high, anchor, 1)

// === EMAs ===
ema9 = ta.ema(close, 9)
rma9 = ta.rma(close, 9)
tsiDynln = period
emaDynln = 9
if timeframe_period == "5S"
    tsiDynln := period
   
    emaDynln := 2700 / 5
if timeframe_period == "10S"
    tsiDynln := period*2
 
    emaDynln :=2700 / 10  
if timeframe_period == "15S"
    tsiDynln := period

    emaDynln := 2700 / 15
if timeframe_period == "30S"
    tsiDynln := period*4

    emaDynln := 2700 / 30
if timeframe_period == "1"
    emaDynln := 2700 / 60

emaSlow = ta.ema(close, emaDynln)
rmaSlow = ta.rma(close, emaDynln)

emaL = close > ema9 and ema9 > rma9  and emaSlow > rmaSlow  and close > emaSlow
emaS = close < ema9 and ema9 < rma9  and rmaSlow >  emaSlow  and close < emaSlow


// plot(emaSlow, "emaSlow", display = display.none)
plotshape(emaL or emaS, "ema sig", display = display.none, color = emaL ? color.green : color.red)

if uptrend_SL
    orderAction := "BUY"
if not uptrend_SL
    orderAction := "SELL"
// === TSI ===
tsi = ta.correlation(close, bar_index, tsiDynln)
tsiLong = (tsi >= periodThresLong) 
tsiShort = (tsi <= periodThresShort) 
// === RSI ===
RSI = ta.rsi(close, rsiLn)
RSIFast = ta.rsi(close, rsiFastLn)
rsiLong = (RSI < RSIFast and RSI > 50)
rsiShort = (RSI > RSIFast and RSI < 50)
//====RSI Oscillator =====
var color rsi_color = na
if rsiLong
    rsi_color:= color.aqua 
if rsiShort
    rsi_color :=  #f68989
shortRsiOsc = ta.rsi(close, 7)
longRsiOsc = ta.rsi(close, 14)
oscRsi = 100 * (shortRsiOsc - longRsiOsc) / longRsiOsc

plotshape(oscRsi, "oscRsi", display=display.none)

plotchar(rsiLong or rsiShort, "rsi sig", "r", location = location.abovebar, color= rsi_color, size= size.tiny,  display = display.none)
// === Volume Oscillator === ocsThresh = input.float(20.0, "Volume Oscillator Threshold", group="Trade Setup")

osc_length_short = input.int(5, "Volume Oscillator Length")
short_vol_ema = ta.ema(volume, osc_length_short)
long_vol_ema = ta.ema(volume, osc_length_short*2)
osc = 100 *( (short_vol_ema - long_vol_ema) / long_vol_ema)
// === Volume Analysis ===
mean = ta.sma(volume, volLen)
std = ta.stdev(volume, volLen)
volStdOne = std  + mean
volStdTwo = std * 2 + mean
volStdThree = std * 3 + mean
volStdOneFive = std * 1.5 + mean

aboveMean = (  osc > 20 or volume > mean) 
belowMean = five_min_test ? false : not aboveMean
above2strDev = volStdTwo <= volume
above3strDev = volStdThree <= volume
liquidThreshcalc = volume / (accountBalance/ close)
liquidThreshSig =  liquidThreshcalc > 15
plotshape(liquidThreshSig, "liquidThreshSig",  display=display.none)

//================================================================Squeeze======================================
sqzDynln = sqz_length
if timeframe_period == "5S"
   
    sqzDynln := sqz_length*60
if timeframe_period == "10S"
    sqzDynln := sqz_length*30    
if timeframe_period == "15S"
    sqzDynln := sqz_length*20
if timeframe_period == "30S"
    sqzDynln := sqz_length*10

//── Bollinger Bands
basis = ta.ema(srSqz, sqz_length)
dev   = bbMult * ta.stdev(srSqz, sqz_length)
bb_ub = basis + dev
bb_lb = basis - dev

//── Keltner Channels
ma    = ta.ema(srSqz, sqz_length)
atr   = ta.atr(10)
kc_ub = ma + kcMult * atr
kc_lb = ma - kcMult * atr

//── Squeeze condition
squeeze = sqz_test ? bb_ub < kc_ub and bb_lb > kc_lb : false

//── Pivot highs/lows


//── Remember last pivot prices
var float lastPh = na
var float lastPl = na
if not na(r2)
    lastPh := ph
if not na(s2)
    lastPl := pl

//── New “within pivot range” condition
inRange = not na(lastPh) and not na(lastPl) and high <= lastPh and low >= lastPl

//── Final consolidation flag
consolidation = squeeze and inRange

// === Conditions ===

if above2strDev
    volumeVar := true
else if not above2strDev
    volumeVar := false

if five_min_bar_close_sig and five_min_test and vol_cond_test
    volCond :=true

if not vol_cond_test 
    volCond :=  (liquidThreshSig and ((volumeVar or volumeVar[1]) and aboveMean) ) or (liquidThreshSig and volStdOneFive < volume)
if vol_cond_test and not five_min_test
    volCond :=  aboveMean

//levelBreakS = ta.crossunder(close, s2) and not(open - close < high - open) and close >= shortPriceThresh 
//levelBreakL = ta.crossover(close, r2) and not(open - low > close - open) 
levelBreakS = ta.crossunder(close, s2) and not(open - close < high - open) and open > close
levelBreakL = ta.crossover(close, r2) and not(open - low > close - open) and open < close


longTrend = emaL and tsiLong and rsiLong and uptrend and vwap < close and not atrLongSqx
shortTrend = emaS and tsiShort and rsiShort and close >= shortPriceThresh and not uptrend  and vwap > close and not atrShortSqx

// === Signal Generation ===

if shortTrend 
    shortTrendSig := true
if longTrend  
    longTrendSig := true
    
if levelBreakS 
    shortLevelBreakSig := true

if levelBreakL
    longLevelBreakSig := true
if belowMean
    shortLevelBreakSig := false
    longLevelBreakSig := false
if not rsiLong 
    longLevelBreakSig := false
    longTrendSig := false
if not rsiShort
    shortLevelBreakSig := false
    shortTrendSig := false

isfirstbar_regular=session.isfirstbar_regular




if longLevelBreakSig  and rsiLong
    bullBreak := true
    bullBreakScan := true
if shortLevelBreakSig  and rsiShort  
    bearBreak := true  
    bearBreakScan := true



if belowMean or  uptrend_change
    volCondSig := false
    bearBreak := false
    bullBreak := false
    shortTrendSig := false
    longTrendSig := false




// Calculate signals

var longAlert = false
var shortAlert = false
longAlert := longLevelBreakSig and volCondSig and longTrend 
shortAlert:= shortLevelBreakSig and volCondSig and shortTrend 
if not shortTrend
    shortAlert := false
if not longTrend
    longAlert := false






//stopType = input.string("vStop", "Stop Type", options=["kcStop", "vStop", "pivot"], group="API Settings")

// === Create Entries and Exits === 

breakScanLong = volCondSigScan and    (bullBreakScan)
breakScanShort = volCondSigScan and    (bearBreakScan)

//alertcondition(breakScanLong or breakScanShort, "breakScanLong or breakScanShort", "breakScanLong or breakScanShort")




//alertcondition(trendSig, "trend Sig - first sig", "trend Sig first sig")

var string alertMessageLongJson = ""
var string alertMessageShortJson = ""
var string alertMessageJson = ""
// Function to create the JSON alert message for long entries



var float sLprice = na
var float lLprice = na



//uptrend_str = uptrend ? "True" : "False
vstop_fix = fixnan(vStop_SL)
stopLossLongCalc := vstop_fix
stopLossShortCalc := vstop_fix
stop_diff = 0.000
stop_diff_prct = 0.00
var float tv_stopLoss = na
if uptrend_SL
    stop_diff_prct := ((low-vstop_fix) / vstop_fix) * 100
    stop_diff:= (low-vstop_fix)
if not uptrend_SL
    stop_diff_prct:= ((vstop_fix-high) / high) * 100
    stop_diff:= (vstop_fix-high) 
if not uptrend_SL
    tv_stopLoss := stop_diff_prct < 0.4 ? close *0.995 : vstop_fix

if  uptrend_SL
    tv_stopLoss := stop_diff_prct < 0.4 ? close *1.005 : vstop_fix

entryPrice = str.contains(ticker_info, "BTC") ? str.tostring(close_string) : str.tostring(close_string)
atrFactorDyn_fix = fixnan(atrFactorDyn)
ticker = str.contains(ticker_info, "BTC") ?  "NVDA" : ticker_info

price_update_alert := math.round(vstop_fix[1], 2) == math.round(vstop_fix, 2) 






updateIbPrice() =>
    json_1 = '{"ticker": "' + ticker + '"' +
           ', "rewardRiskRatio": ' + str.tostring(rewardRiskRatio) + 
           ', "orderAction":  "updateIbPrice"' + 
           ', "timeframe": "' + str.tostring(timeframe_period) + '"' +
           ', "quantity": ' + str.tostring(-1) + 
           ', "riskPercentage": ' + str.tostring(riskPercentage) + 
           ', "kcAtrFactor": ' + str.tostring(atrFactorDyn_fix) + 
           ', "atrFactor": ' + str.tostring(atrFactor) + 
           ', "vstopAtrFactor": ' + str.tostring(atrFactorDyn_fix) + 
           ', "accountBalance": ' + str.tostring(accountBalance) + 
           ', "entryPrice":' + entryPrice + 
           ', "stopType": "' + stopType + '"' + 
           ', "takeProfitBool": ' + str.tostring(takeProfitBool) + 
           ', "stopLoss": ' + str.tostring(tv_stopLoss) + 
           ', "uptrend": ' + str.tostring(uptrend) +
           ', "unixtime": ' + str.tostring(time_unix) +
           ', "submit_cmd": ' + str.tostring (submit_cmd) + 
           '}'
    json_1



orderEntryJson(qty, takeProfitBool) =>
    json_entry = '{"ticker": "' + ticker + '"' +
           ', "orderAction": "' + orderAction + '"' +
           ', "rewardRiskRatio": ' + str.tostring(rewardRiskRatio) + 
           ', "timeframe": "' + str.tostring(timeframe_period) + '"' +
           ', "quantity": ' + str.tostring(qty) + 
           ', "riskPercentage": ' + str.tostring(riskPercentage) + 
           ', "kcAtrFactor": ' + str.tostring(atrFactorDyn_fix) + 
           ', "atrFactor": ' + str.tostring(atrFactor) + 
           ', "vstopAtrFactor": ' + str.tostring(atrFactorDyn_fix) + 
           ', "accountBalance": ' + str.tostring(accountBalance) + 
           ', "entryPrice":' + entryPrice + 
           ', "stopType": "' + stopType + '"' + 
           ', "takeProfitBool": ' + str.tostring(takeProfitBool) + 
           ', "stopLoss": ' + str.tostring(tv_stopLoss) + 
           ', "uptrend": ' + str.tostring(uptrend) +
           ', "unixtime": ' + str.tostring(time_unix) +
           ', "submit_cmd": ' + str.tostring (submit_cmd) + 
           '}'
    json_entry


//––– Inputs
AVOL_length = input.int(30, "AVOL Length")
subtractFirstBarVolume = input.bool(true, "Subtract First Bar Volume")

// Get Eanings Per Share Estimate and Earnings Per Share Diluted
EPS_estimate = request.earnings(syminfo.tickerid, earnings.estimate)
EPS_diluted = request.financial(syminfo.tickerid, 'EARNINGS_PER_SHARE_DILUTED', 'FQ')
// Calculate eranings date
Earnings_date = ta.barssince(EPS_estimate - EPS_estimate[1] != 0) == 0

last_bar=session.islastbar
last_reg_bar=session.islastbar_regular
var float pre_eps_volume = na
var float post_eps_volume =na
var bool earnings_bool = false
var bool earnigs_entry_sig = false



//––– Daily AVOL via security call (yesterday’s volume)
dVol = request.security(syminfo.tickerid, "D", volume[1], lookahead=barmerge.lookahead_on)
AVOL = ta.sma(dVol, AVOL_length)
var float ehVol =na
//––– Session definitions
inPre    = session.ispremarket 
inPost   = session.ispostmarket

//––– Pre‑market volume
var float pmVol = 0.0
pmVol := inPre and not inPre[1] ? volume
     : inPre ? pmVol[1] + volume
     : pmVol[1]

//––– After‑hours volume
var float firstPostVol = 0.0
if inPost and not inPost[1]
    firstPostVol := volume
var float ahVol_W_earnings = 0.0
var float ahVol = 0.0

if last_reg_bar
    earnigs_entry_sig := false
    
    earnings_bool := false
    ahVol_W_earnings := 0.0
    pmVol :=0.0
    ahVol := 0.0
    ehVol :=0
    post_eps_volume :=na
    pre_eps_volume := na
if Earnings_date
    earnings_bool := true
if not earnings_bool
    ahVol_W_earnings := 0

ahVol_W_earnings:= nz(ahVol_W_earnings[1], 0.0)
ahVol_W_earnings := inPost  and not inPost[1]
         ? (subtractFirstBarVolume ? 0 : volume)
     : inPost 
         ? ahVol_W_earnings[1] + volume - (not inPost[1] and subtractFirstBarVolume ? firstPostVol : 0)
     : ahVol_W_earnings[1]
if not earnings_bool
    ahVol_W_earnings := 0
//––– Combined EH volume (only during pre‑market bars)
ahVol:= nz(ahVol[1], 0.0)
ahVol := inPost  and not inPost[1]
         ? (subtractFirstBarVolume ? 0 : volume)
     : inPost 
         ? ahVol[1] + volume - (not inPost[1] and subtractFirstBarVolume ? firstPostVol : 0)
     : ahVol[1]



if not earnings_bool
    ehVol :=0
    post_eps_volume := na
    pre_eps_volume :=na
pmVol_fix = fixnan(pmVol)
ahVol_fix_e = fixnan(ahVol_W_earnings)
ahVol_fix = fixnan(ahVol)


all_vol= ahVol_fix + pmVol_fix
if earnings_bool
    post_eps_volume := ahVol_fix_e
    pre_eps_volume := pmVol_fix

ehVol := pre_eps_volume + post_eps_volume
//log.info("ehVol {0}", ehVol)
ehVol_fix = fixnan(ehVol)


//––– %AVOL
pctAH = math.round(ahVol_fix_e  / AVOL * 100)
pctPM = math.round(pmVol_fix  / AVOL * 100)
pctEH = math.round(ehVol_fix  / AVOL * 100)
pctall_vol =  math.round(all_vol  / AVOL * 100)
pct   = pctEH

//plotshapepct, title="%AVOL", color=color.yellow)
if pct >= pre_rvol_thresh
    earnigs_avol_sig :=true
earnigs_entry_sig := earnings_bool ? earnigs_avol_sig : pctall_vol >= pre_rvol_thresh * 2
bgcolor(earnigs_entry_sig ? color.new(#ddff96, 69) : na, display = display.none, title = 'earnigs_entry_sig')
//plotshapeearnigs_avol_sig , "earnigs_avol_sig")
signalEntryLongScan := longTrendSig and bullBreak and five_min_bar_close_sig

signalEntryShortScan := shortTrendSig and bearBreak   and five_min_bar_close_sig

if not longTrendSig or not bullBreak  or not five_min_bar_close_sig
    signalEntryLongScan := false
if not shortTrendSig or not bearBreak  or not five_min_bar_close_sig
    signalEntryShortScan := false

var string profit_str = na
net_profit= strategy.netprofit 
open_profit = strategy.openprofit 

if stratType == 'Trend with Volume Break' 

    signalEntryLong := longTrendSig and bullBreak

    signalEntryShort := shortTrendSig and bearBreak   

if stratType == "Bull/Bear Break only"

    signalEntryLong := bullBreak

    signalEntryShort :=  bearBreak   

scalp_squeeze = bb_ub < kc_ub and bb_lb > kc_lb
if stratType == "Five Min Scalp"

    signalEntryLong := longTrend and five_min_bar_close_sig and aboveMean and not scalp_squeeze  

    signalEntryShort :=  shortTrend  and five_min_bar_close_sig and aboveMean and not scalp_squeeze 

commonEntry := ((noPosition and noPosition[1] and noPosition[2])     and currentTrades < trade_limit  and not longE and not shortE) and not newEntry and not newEntry[1] and not isfirstbar_regular and unixTimeCond and (ismarket or afterHoursOrder) and not squeeze 
price_update := (commonEntry and (math.round(vstop_fix[1], 2) != math.round(vstop_fix, 2) ) ) or isfirstbar_regular

if (signalEntryLong and commonEntry)

    stopHigh := stopLossLongCalc
    longStopPrice := stop_diff_prct < 0.4 ? close *0.995 : stopHigh
    longEntryPrice      := close
    toleratedRisk  := math.abs((riskPercentage / 100 * (accountBalance*0.95)) - brokerComish)
    perShareRisk   := math.abs(longEntryPrice - longStopPrice)
    pQtyL          := math.round(math.min(toleratedRisk / perShareRisk, math.floor((accountBalance*0.95) / longEntryPrice)))
    grossCommission := pQtyL * commissionValue
    tradeValue     := pQtyL * longEntryPrice
    longLimitPrice := math.round(longEntryPrice + rewardRiskRatio * (longEntryPrice - longStopPrice), 2)
    
    commission     := math.min(math.max(grossCommission, minCommission), tradeValue * maxPercentage)
    QtytL          := math.round(math.min((toleratedRisk)/perShareRisk, math.floor((accountBalance*0.95)/longEntryPrice)))
    
   
    strategy.entry("Long", strategy.long, alert_message= orderEntryJson(QtytL,  limitOrderType == "Bracket Order" and stratType != "Five Min Scalp"), qty = QtytL)
    
    newEntry := true
    

    if limitOrderType != "Bracket Order" 
        strategy.exit("Exiit Long SL", "Long", stop=longStopPrice, qty=QtytL,  disable_alert=true)
    if (limitOrderType == "Bracket Order" and stratType != "Five Min Scalp")
        strategy.exit("Long SL/TP", "Long", stop=longStopPrice, qty=QtytL,  limit=longLimitPrice, disable_alert=true)

plotshape(QtytL, "QtytL")
plotshape(longStopPrice, "longStopPric", color=color.white)

if (signalEntryShort and commonEntry) 
    stopLow := stopLossShortCalc
    shortEntry := close
    shortStopPrice  :=  stop_diff_prct < 0.4 ? close *1.005 : stopLow
    perShareRisk    :=  math.abs(shortEntry - shortStopPrice)
    toleratedRisk   := math.abs((riskPercentage / 100 * (accountBalance*0.95)) - brokerComish)
    pQtyS           := math.round(math.min(toleratedRisk / perShareRisk, math.floor((accountBalance*0.95) / shortEntry)))
    grossCommission := pQtyS * commissionValue
    tradeValue      := pQtyS * shortEntry
    shortLimitPrice := math.round(shortEntry - rewardRiskRatio * (shortStopPrice - shortEntry), 2)
    commission      := math.min(math.max(grossCommission, minCommission), tradeValue * maxPercentage)
    QtytS           := math.round(math.min(toleratedRisk/perShareRisk, math.floor((accountBalance*0.95)/shortEntry)))
    

    
    strategy.entry("Short", strategy.short, alert_message=orderEntryJson(QtytS,  limitOrderType == "Bracket Order" and stratType != "Five Min Scalp"), qty=QtytS)
    newEntry := true
    if limitOrderType != "Bracket Order"
        strategy.exit("Short Exit SL", "Short", stop=shortStopPrice, qty=QtytS,  disable_alert=true)
    if (limitOrderType == "Bracket Order" and stratType != "Five Min Scalp")
        strategy.exit("Short SL/TP", "Short", stop=shortStopPrice, qty=QtytS,  limit=shortLimitPrice, disable_alert=true)

if ( (testEntry and price_update and  uptrend and close > high[1] )) and commonEntry 

    stopHigh := stopLossLongCalc
    longStopPrice := stop_diff_prct < 0.4 ? close *0.995 : stopHigh
    longEntryPrice      := close
    toleratedRisk  := math.abs((riskPercentage / 100 * (accountBalance*0.95)) - brokerComish)
    perShareRisk   := math.abs(longEntryPrice - longStopPrice)
    pQtyL          := math.round(math.min(toleratedRisk / perShareRisk, math.floor((accountBalance*0.95) / longEntryPrice)))
    grossCommission := pQtyL * commissionValue
    tradeValue     := pQtyL * longEntryPrice
    longLimitPrice := math.round(longEntryPrice + rewardRiskRatio * (longEntryPrice - longStopPrice), 2)
    
    commission     := math.min(math.max(grossCommission, minCommission), tradeValue * maxPercentage)
    QtytL          := math.round(math.min((toleratedRisk)/perShareRisk, math.floor((accountBalance*0.95)/longEntryPrice)))
    
   
    strategy.entry("Long", strategy.long, alert_message= orderEntryJson(QtytL,  limitOrderType == "Bracket Order" and stratType != "Five Min Scalp"), qty = QtytL)
    
    newEntry := true
    if limitOrderType != "Bracket Order"
        strategy.exit("testEntry Long Exit SL", "Long", stop=longStopPrice, qty=QtytL,  disable_alert=true)
    if (limitOrderType == "Bracket Order"  and stratType != "Five Min Scalp")
        strategy.exit(" testEntry Long SL/TP", "Long", stop=longStopPrice, qty=QtytL,  limit=longLimitPrice, disable_alert=true)



if (testEntry and  price_update  and not uptrend and close < low[1]) and commonEntry 
    stopLow := stopLossShortCalc
    shortEntry := close
    shortStopPrice  :=  stop_diff_prct < 0.4 ? close *1.005 : stopLow
    perShareRisk    :=  math.abs(shortEntry - shortStopPrice)
    toleratedRisk   := math.abs((riskPercentage / 100 * (accountBalance*0.95)) - brokerComish)
    pQtyS           := math.round(math.min(toleratedRisk / perShareRisk, math.floor((accountBalance*0.95) / shortEntry)))
    grossCommission := pQtyS * commissionValue
    tradeValue      := pQtyS * shortEntry
    shortLimitPrice := math.round(shortEntry - rewardRiskRatio * (shortStopPrice - shortEntry), 2)
    commission      := math.min(math.max(grossCommission, minCommission), tradeValue * maxPercentage)
    QtytS           := math.round(math.min(toleratedRisk/perShareRisk, math.floor((accountBalance*0.95)/shortEntry)))
    

    
    strategy.entry("Short", strategy.short, alert_message=orderEntryJson(QtytS,  limitOrderType == "Bracket Order" and stratType != "Five Min Scalp"), qty=QtytS)
    newEntry := true
    if limitOrderType == "Stoploss Only"
        strategy.exit("testEntry Short Exit SL", "Short", stop=shortStopPrice, qty=QtytS,  disable_alert=true)
    if (limitOrderType == "Bracket Order"  and stratType != "Five Min Scalp")
        strategy.exit(" testEntry Short SL/TP", "Short", stop=shortStopPrice, qty=QtytS,  limit=shortLimitPrice, disable_alert=true)

if position_size != 0 
    shortLimitPricePlot := shortLimitPrice
qty_both = uptrend ? QtytL : QtytS
if not commonEntry
    newEntry := false
plotshape(newEntry, "newEntry", color=color.rgb(205, 54, 208),  display = display.none)
plotshape( price_update and not price_update_alert , "price alert", display = display.none)
if price_update 
    
    alert(updateIbPrice(), alert.freq_once_per_bar_close)
    price_update_alert := false
var float stop_line_long = na
var float stop_line_short = na
stop_line_long:=  not ismarket   ? na : na
stop_line_short:= not ismarket ? na : na
stop_line_long:= longE    ? longStopPrice : na
stop_line_short:= shortE   ? shortStopPrice : na
plotshape(longE or shortE, "longE or shortE", style=shape.circle, color= not uptrend_SL ? #009688 : #F44336)



//plot(stop_line_long, "stop_line_long", color=color.green)
//plot(stop_line_short, "stop_line_short", color=color.red)

var float bar_stoploss = na
if longE
    bar_stoploss := low[1]
    
if shortE
    bar_stoploss := high[1]

alertMessageCloseALl()  =>
    json_3 = '{"ticker": "' + ticker + '"' +
           ', "orderAction": "close_all"' + 
           ', "rewardRiskRatio": ' + str.tostring(rewardRiskRatio) +
           ', "timeframe": "' + str.tostring(timeframe_period) + '"' +
           ', "quantity": ' + str.tostring(-1) + 
           ', "riskPercentage": ' + str.tostring(riskPercentage) + 
           ', "kcAtrFactor": ' + str.tostring(atrFactorDyn_fix) + 
           ', "atrFactor": ' + str.tostring(atrFactor) + 
           ', "vstopAtrFactor": ' + str.tostring(atrFactorDyn_fix) + 
           ', "accountBalance": ' + str.tostring(accountBalance) + 
           ', "entryPrice":' + entryPrice + 
           ', "stopType": "' + stopType + '"' + 
           ', "takeProfitBool": ' + str.tostring(takeProfitBool) + 
           ', "stopLoss": ' + str.tostring(tv_stopLoss) + 
           ', "unixtime": ' + str.tostring(time_unix) +
           ', "uptrend": ' + str.tostring(uptrend) +
           ', "submit_cmd": ' + str.tostring (submit_cmd) + 
           '}'
    json_3





Buy_cover_sl = ta.crossover(close, vStop_SL) and not uptrend_SL
Sell_sl = ta.crossunder(close, vStop_SL) and  uptrend_SL

plot(vstop_fix, "Volatility Stop Trailing SL", style=plot.style_steplinebr, color= not uptrend_SL ? #009688 : #F44336)
plotshape(atrLongSqx, "stoploss atrLongSqx")
plotshape(atrShortSqx, "stoploss atrShortSqx")
plotshape(atrLongSqx, 'atrLongSqx', shape.labelup, location.belowbar, color.new(color.green, 0), display=display.none)
plotshape(atrShortSqx, 'atrShortSqx', shape.labeldown, location.abovebar, color.new(color.red, 0), display=display.none)

plotshape(Buy_cover_sl, 'SL BUY Cover', shape.labelup, location.belowbar, color.new(color.green, 0), text='BUY', textcolor=color.new(color.black, 0), display=display.none)
plotshape(Sell_sl, 'SL SELL', shape.labeldown, location.abovebar, color.new(color.red, 0), text='SELL', textcolor=color.new(color.black, 0), display=display.none)


if not closeAllSig and  (longE and close < bar_stoploss) and closeType == "Bar Stoploss" and limitOrderType !="Bracket Order"
    
    
    strategy.close_all("close_all bar_stoploss Long")
    alert(alertMessageCloseALl(), alert.freq_once_per_bar_close)
    closeAllSig:= true

if not closeAllSig and  (shortE and close > bar_stoploss)  and closeType == "Bar Stoploss" and limitOrderType !="Bracket Order"
    
    
    strategy.close_all("close_all bar_stoploss Short")
    alert(alertMessageCloseALl(), alert.freq_once_per_bar_close)
    closeAllSig:= true

atrTrendChange = ta.change(uptrend_SL)
if not closeAllSig and  longE and ((atrTrendChange or Sell_sl)) and closeType == "ATR Stoploss" and  limitOrderType !="Bracket Order"
    strategy.close_all("close_all atr stoploss long")
    alert(alertMessageCloseALl(), alert.freq_once_per_bar)
    closeAllSig:= true


    
if not closeAllSig and shortE and ((atrTrendChange or Buy_cover_sl) )  and closeType == "ATR Stoploss" and  limitOrderType !="Bracket Order"
    strategy.close_all("close_all atr stoploss short")
    alert(alertMessageCloseALl(), alert.freq_once_per_bar)
    closeAllSig:= true   
    



plotshape(bullBreak and longTrend, "trade entry long",display=display.none)

plotshape(bearBreak and shortTrend, "trade entry short",display=display.none)
plotshape(totalTrades, "totalTrades",display=display.none)

plotshape(position_size != 0 ? open_profit : net_profit , "strategy.openprofit_percent ",display=display.none)
plotshape(netprofit_percent  >= 1, "strategy.openprofit_percent  >= 1.5 ", color=#2ae600,display=display.none)

if openprofit_percent >= openprofit_percent_level and closeType == "Profit Target" and  limitOrderType !="Bracket Order"
    strategy.close_all("close_all -profit target", alertMessageCloseALl(), true    )


close_time= time_unix >= last_bar_59
//plotshapeclose_time, "close_time", color=color.purple)

//plotshapeprice_update , "alert", display = display.none)
//closeAllAlertMsg=alertMessageCloseALl() 
    
closeAllAtEndOfRegularSession() =>
    if close_time  
        true
         
    
closeAllAtEndOfRegularSession()
if not closeAllSig  and  closeAllAtEndOfRegularSession() 
    if (longE or shortE)  and (ismarket) 
        strategy.close_all("close_all end of day", alertMessageCloseALl(), true    )
    

plotshape(closeAllSig, "closeAllSig",  display = display.none)



//Plots

plot(vStop_SL, "Volatility Stop", style=plot.style_circles, color= uptrend ? #009688 : #F44336)
//These plots are not needed for Python, they are here to give an example
u = plot(kcUpper, color=color.rgb(41, 255, 155), title="Upper", style = plot.style_line, linewidth= 2, display = display.none)
plot(ema, color=color.rgb(41, 230, 255), title="Basis",style = plot.style_line, linewidth= 2, display = display.none)
l = plot(kcLower, color=#f77a7a, title="Lower",style = plot.style_line, linewidth= 2, display = display.none)




    




//── Plot
//volCond =  liquidThreshSig and (volumeVar or (volumeVar[1] and aboveMean)  or (volStdOneFive < volume))





bgcolor(squeeze ? color.new(color.gray, 90) : na)
bullBreakTest = longLevelBreakSig and volCond and rsiLong and not isfirstbar_regular    
bearBreakTest = shortLevelBreakSig and volCond and rsiShort and not isfirstbar_regular     
plotshape(bullBreakTest, "Long bullBreakTest", color=#9ffa0b, style=shape.cross, location=location.belowbar, size=size.small, display = display.none)
plotshape(bearBreakTest, "Short bearBreakTest", color=color.rgb(248, 83, 83), style=shape.cross, location=location.abovebar, size=size.small , display = display.none)
plotshape(pine_tr > vola_level, "pine_tr > vola_level", color=#b69ef4, style=shape.cross, location=location.abovebar, size=size.small , display = display.none)
plotshape(volCond, "volCond", color=#e600ff, style=shape.cross, location=location.abovebar, size=size.small , display = display.none)
plotshape(belowMean, "belowMean", color=color.rgb(255, 247, 0), style=shape.cross, location=location.belowbar, size=size.small , display = display.none)


plotshape(levelBreakL, "Long levelBreakL", color=#9ffa0b, style=shape.cross, location=location.belowbar, size=size.small, display = display.none)
plotshape(levelBreakS, "Short levelBreakS", color=color.rgb(248, 83, 83), style=shape.cross, location=location.abovebar, size=size.small , display = display.none)

plotshape(close > r2 and open < r2, "Long close above level level", color=#9ffa0b, style=shape.xcross, location=location.belowbar, size=size.small, display = display.none)
plotshape(close < s2 and open > s2, "Short close below level", color=color.rgb(248, 83, 83), style=shape.xcross, location=location.abovebar, size=size.small , display = display.none)

plotshape(longAlert,"longAlert", color=color.rgb(41, 196, 27), style=shape.triangleup, location=location.belowbar, size=size.small,display=display.none)
plotshape(shortAlert, "shortAlert", color=#c41b1b, style=shape.triangledown, location=location.abovebar, size=size.small,display=display.none)
plotshape(breakScanLong, "breakScanLong", color= #009688 , style=shape.labelup, location=location.belowbar, size=size.small, display=display.none)
plotshape(breakScanShort, "breakScanShort", color= #F44336, style=shape.labeldown, location=location.abovebar, size=size.small,  display=display.none)
plotchar(bullBreak,"bullBreak", "b", color=color.rgb(41, 196, 27),  location=location.belowbar, size=size.tiny,  display=display.none)
plotchar(bearBreak, "bearBreak", "b", color=#c41b1b, location=location.abovebar, size=size.tiny,  display=display.none)
plotshape(longTrendSig, "longTrendSig" ,color= #009688,  style=shape.arrowup, location=location.top,display=display.none)
plotshape(shortTrendSig, "shortTrendSig", color=  #F44336,  style=shape.arrowdown, location=location.top,display=display.none)


plot(stopLow, "stopLow",  color=color.red,display=display.none)
plot(stopHigh, "stopHigh", color=color.green,display=display.none)
plot(shortLimitPricePlot, "shortLimitPrice",  color=color.red, style= plot.style_cross, display=display.none)
plot(longLimitPrice, "longLimitPrice", color=color.green, style= plot.style_cross, display=display.none)
plotshape(signalEntryLong, "signalEntryLong", style=shape.flag, color=color.green,   display=display.none)
plotshape(signalEntryShort, "signalEntryShort", style=shape.flag,color=color.red,   display=display.none)

profit_str := strategy.opentrades != 0 ?  str.tostring(open_profit) : str.tostring(net_profit)

plotshape(commonEntry, "commonEntry", shape.circle, color=color.rgb(255, 119, 169) , location = location.top, display=display.none)

plotshape(earnings_bool, "earnings_bool", shape.circle, color=#77c2ff,display=display.none)

plotshape(currentTrades, "currentTrades", style=shape.diamond, color=color.lime,display=display.none)